<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="iOS 存储方案从入门到精通引导语在业务开发过程中，对于数据的处理，总是占有很大一部分时间。而又根据不同的业务需要，存储方案可以进行不同的选择。从数据存储的位置角度来分的话，存储可以分为内存存储和硬盘存储。内存存储，数据交互快，在一些需要复杂耗时的地方可以考虑内存缓存来解决。而磁盘存储，由于磁盘本身的特点，当触发操作时，需要一些磁盘变道等物理操作，交互速度会大大降低，但是由于可以保存大量数据，数据">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 存储方案从入门到精通">
<meta property="og:url" content="http://yoursite.com/2018/06/25/iOS-存储方案从入门到精通/index.html">
<meta property="og:site_name" content="junlong的博客">
<meta property="og:description" content="iOS 存储方案从入门到精通引导语在业务开发过程中，对于数据的处理，总是占有很大一部分时间。而又根据不同的业务需要，存储方案可以进行不同的选择。从数据存储的位置角度来分的话，存储可以分为内存存储和硬盘存储。内存存储，数据交互快，在一些需要复杂耗时的地方可以考虑内存缓存来解决。而磁盘存储，由于磁盘本身的特点，当触发操作时，需要一些磁盘变道等物理操作，交互速度会大大降低，但是由于可以保存大量数据，数据">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e61f870b4d551?w=1178&h=508&f=jpeg&s=86243">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e620bfaf41c70?w=948&h=528&f=jpeg&s=44196">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e6216b22b30bd?w=557&h=199&f=jpeg&s=23215">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e621ddc16510e?w=565&h=315&f=jpeg&s=33025">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e622225f6850b?w=433&h=203&f=jpeg&s=20884">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e6232e5bc8731?w=315&h=383&f=jpeg&s=44910">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e6240c86a4c4d?w=559&h=366&f=jpeg&s=29584">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e624597c2620e?w=561&h=370&f=jpeg&s=25649">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e624d3b5f2601?w=363&h=350&f=jpeg&s=46302">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e6270e081c964?w=800&h=514&f=jpeg&s=107050">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e628810d2ab34?w=856&h=735&f=jpeg&s=128002">
<meta property="og:updated_time" content="2018-06-25T13:01:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS 存储方案从入门到精通">
<meta name="twitter:description" content="iOS 存储方案从入门到精通引导语在业务开发过程中，对于数据的处理，总是占有很大一部分时间。而又根据不同的业务需要，存储方案可以进行不同的选择。从数据存储的位置角度来分的话，存储可以分为内存存储和硬盘存储。内存存储，数据交互快，在一些需要复杂耗时的地方可以考虑内存缓存来解决。而磁盘存储，由于磁盘本身的特点，当触发操作时，需要一些磁盘变道等物理操作，交互速度会大大降低，但是由于可以保存大量数据，数据">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2018/4/21/162e61f870b4d551?w=1178&h=508&f=jpeg&s=86243">






  <link rel="canonical" href="http://yoursite.com/2018/06/25/iOS-存储方案从入门到精通/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>iOS 存储方案从入门到精通 | junlong的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">junlong的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">热爱技术，热爱生活</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/25/iOS-存储方案从入门到精通/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujunlong">
      <meta itemprop="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junlong的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS 存储方案从入门到精通
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-25 20:56:04 / Modified: 21:01:11" itemprop="dateCreated datePublished" datetime="2018-06-25T20:56:04+08:00">2018-06-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="iOS-存储方案从入门到精通"><a href="#iOS-存储方案从入门到精通" class="headerlink" title="iOS 存储方案从入门到精通"></a>iOS 存储方案从入门到精通</h1><h2 id="引导语"><a href="#引导语" class="headerlink" title="引导语"></a>引导语</h2><p>在业务开发过程中，对于数据的处理，总是占有很大一部分时间。而又根据不同的业务需要，存储方案可以进行不同的选择。从数据存储的位置角度来分的话，存储可以分为内存存储和硬盘存储。内存存储，数据交互快，在一些需要复杂耗时的地方可以考虑内存缓存来解决。而磁盘存储，由于磁盘本身的特点，当触发操作时，需要一些磁盘变道等物理操作，交互速度会大大降低，但是由于可以保存大量数据，数据可以一直持有，可以在app被关闭后，数据可以重新被加载到程序中，所以在iOS端也提供了非常多的方式来把数据保存到磁盘。</p>
<p>在接下来的内容中，我会分别介绍内存存储和磁盘存储的适用场景，由于内存存储比较简单，所以重点会放在磁盘存储空间上。而磁盘存储又可以分为文件系统和数据库系统，而数据库系统也是我们在业务中遇到问题最多的地方，所以在简单介绍文件系统的相关适用场景及各个文件存储方案的原理及优劣后，会花大量篇幅介绍数据库系统，而数据库系统，在移动端的解决方案中，<code>SQLite</code>数据库的解决方案也是应用最为广泛的。我会介绍<code>SQLite</code>的相关原理，以此来探究一些性能问题。由于多线程操作一直很神秘，也经常容易出错，所以从<code>SQLite</code>底层的角度来一探究竟。</p>
<h2 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h2><p>内存存储也可以称为内存缓存，因为内存存储的数据只保留在APP启动时。比如保存一些从服务端获取到的数据，来缓解服务器的压力，并且节约了用户流量和时间，提高了用户使用体验。<code>NSURLConnection</code>默认会缓存资源在内存。内存缓存还可以保留一些处理好的数据，比如Feed流把处理好的数据存储到内存缓存中，等到再次使用的时候直接从缓存中取。常见的内存缓存框架有<code>NSCache</code>、<code>TMMemoryCache</code>、<code>PINMemoryCache</code>、<code>YYMemoryCache</code>。<code>NSCache</code> 是苹果提供的一个简单的内存缓存，它有着和 <code>NSDictionary</code> 类似的 API，不同点是它是线程安全的。<code>YYMemoryCache</code> 缓存内部用<code>双向链表</code>和 <code>NSDictionary</code> 实现了 <code>LRU 淘汰算法</code>(Least recently used，最近最少使用)。<br>一般内存缓存的大致流程如下所示： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e61f870b4d551?w=1178&amp;h=508&amp;f=jpeg&amp;s=86243" alt=""></p>
<ol>
<li>APP会优先请求内存缓冲中的资源</li>
<li>如果内存缓冲中有，则直接返回资源文件， 如果没有的话，则会请求资源文件，这时资源文件可能存储在服务端，需要进行网络请求获取，也可以是本地文件，需要操作文件系统或数据库来获取。</li>
<li>获取到的资源文件，先缓存到内存缓存，方便以后不再重复获取，节省时间。</li>
<li>然后就是从缓存中取到数据然后给app使用。</li>
</ol>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p>内存存储适合存储一些app高频次使用，并且所占空间不大的文件。而磁盘存储则可以存储一些需要持久化的文件，信息等。简单的讲就是app被杀死以后，文件仍然在。而磁盘存储根据数据管理方式又可以分为两大类：文件系统存储和数据库系统存储。<br>文件系统把数据组织成相互独立的数据文件。实现了记录内部结构性，但整体无结构。而数据库系统实现了整体数据的结构化。<br>数据库系统主要管理数据库的存储，事务，以及对数据库的操作。而文件系统是操作系统管理文件和存储空间的子系统。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e620bfaf41c70?w=948&amp;h=528&amp;f=jpeg&amp;s=44196" alt=""></p>
<h3 id="磁盘存储方式的选择"><a href="#磁盘存储方式的选择" class="headerlink" title="磁盘存储方式的选择"></a>磁盘存储方式的选择</h3><p>根据操作系统和文件系统的特点，假如存储的数据是结构化的，想要易于统计分析，那么就可以选择数据库来存储。如果存储数据结构单一，并且可能单个数据量大，则可以使用文件系统管理。<br>比如说在百度音乐app内，歌曲信息包含歌曲播放链接，歌曲名，歌手名，所属专辑等信息，这些信息数据量小，但是结构化，并且对于所有的歌曲要进行频繁的统计，和比较细粒度的数据处理。那么就非常适合用数据库来管理。而下载到本地的歌曲，下载到本地的视频等信息，则非常适合用文件管理系统来存储数据。</p>
<h3 id="文件系统管理方式"><a href="#文件系统管理方式" class="headerlink" title="文件系统管理方式"></a>文件系统管理方式</h3><p>文件系统是操作系统管理文件和存储空间的子程序。在iOS系统中还提供了一些文件存储方案。<br>存储方案有<code>plist文件存储</code>，<code>NSUserDefalut存储</code>，<code>keyChain存储</code>，<code>NSKeyedArchiver</code>（序列化存储）。<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6216b22b30bd?w=557&amp;h=199&amp;f=jpeg&amp;s=23215" alt=""></p>
<h4 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h4><p><code>plist文件</code>通常用来存储用户设置，还可以存储程序中经常用到而不经常改动的数据。比如一个app内部常用的颜色，配置信息，可以存储在<code>plist</code>中。结构清晰，易于查找。<br>plist文件是一种存储串行化后的对象文件。文件格式是XML的。plist文件可以通过系统的方法进行读取，却不可以直接对plist文件进行修改。(plist可以变换一种思路进行修改，但是却不建议使用。)</p>
<h4 id="NSUserDefaults存储"><a href="#NSUserDefaults存储" class="headerlink" title="NSUserDefaults存储"></a>NSUserDefaults存储</h4><p><code>NSUserDefaults</code>使用起来简单，如果要存储一些简单的字符串，比如存储字符串，数字等，则<code>NSUSerDefaults</code> 是首选。<br><code>NSUserDefaults</code> 是<code>plist</code>文件的缓存，当用<code>NSUserDefaults</code>写数据的时候，其实是将数据写入到一个专门为<code>NSUserDefaults</code>准备的<code>plist</code>文件中的。 <code>NSUserDefaults</code>可以对这个特殊的<code>plist</code>文件读和写。<br>由于<code>NSUserDefaults</code>会将<code>plist</code>文件的数据读取到缓存中，因此访问速度会很快。</p>
<h4 id="KeyChain"><a href="#KeyChain" class="headerlink" title="KeyChain"></a>KeyChain</h4><p> <code>KeyChain</code>是一个安全的存储容器，所以非常适合保存一些敏感信息到设备中。<code>KeyChain</code>里的数据独立于每个app沙盒之外。即便app被卸载，只要不重新安装系统，存储的信息依然存在，再次安装app，存储的信息依然可以被app使用。通过<code>keychain access groups</code>可以在不同应用之间共享<code>keychain</code>中的数据。要求在保存数据到<code>keychain</code>的时候指定<code>group</code>。<br> 发现百度系的一些app实现的账号互通，应该就是通过<code>keychain access groups</code>来实现的。<br> <code>KeyChain</code>可以存储一些即便app被删除了，下次安装的时候仍然想被用户使用的数据。 </p>
<p> <code>KeyChain</code>数据保存的地方是一个<code>sqlite数据库</code>，位于<code>/private/var/Keychains/keychain-2.db</code>，其保存的所有数据都是加密过的。从这个意义讲，KeyChain的数据是存储在数据库中的，然而由于他只用来存储比较简单的数据，所以就放到了文件分类里。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e621ddc16510e?w=565&amp;h=315&amp;f=jpeg&amp;s=33025" alt=""></p>
<h4 id="NSKeyedArchiver"><a href="#NSKeyedArchiver" class="headerlink" title="NSKeyedArchiver"></a>NSKeyedArchiver</h4><p> 几乎任何类型的对象都能被归档储存。可以使用<code>NSKeyedArchiver</code>进行归档，<code>NSKeyedUnarchiver</code>进行解档。这种方式会在写入、读取数据之前对数据进行序列化、反序列化操作。<br> 对系统自带的简单对象（比如对<code>Foundation</code>框架里的<code>NSString</code>，<code>NSNumber</code>等）可以直接进行归档，而对自定义的对象需要实现NSCoding协议，实现<code>encode</code>和<code>decode</code>方法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e622225f6850b?w=433&amp;h=203&amp;f=jpeg&amp;s=20884" alt="归档"><br><code>NSKeyedArchiver</code>提供了序列化和反序列化的方法，而真正要存储到文件系统的什么地方是可以自定义的。可以将序列化的数据直接写入到文件系统中。也可以利用<code>NSUSerDefaults</code>写到到<code>plist</code>文件中。<br>所以<code>NSKeyedArchiver</code>非常适合把一个自定义的对象序列化后存储到文件系统中去。 </p>
<h4 id="文件-存储"><a href="#文件-存储" class="headerlink" title="文件 存储"></a>文件 存储</h4><p>将数据转化为<code>NSData</code>对象，然后直接利用系统函数，把数据保存到指定的文件目录下。图片，歌曲，视频一般都是通过这种形式存储的。 </p>
<h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>可以看到，iOS提供一些非常方便的文件存储方式。 如果有些数据结构比较简单，存储的条数不是很多，或者单个的数据量太大（音频文件），一些不用修改的信息，选择iOS系统提供的方法就能完成任务需求。 </p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>当数据信息量比较大，并且结构比较的多的时候，存成文件，每次都要把所有的文件读取完，才能进行文件的统计和相关修改操作。 并且文件系统没法了解文件内部数据之间的关系。因此便有了数据库系统，这个系统专门用维护数据以及数据之间的关系。<br>数据库可以理解为仓库管理系统。 一个家具厂的仓库，要取家具，添加新的家具，把原来的家具改为新的家具样式，都需要通过仓库管理系统来实现。只不过这个数据库管理系统管理的是数据而已。  </p>
<p>iOS也提供了一些操作数据库的实现，包括<code>CoreData</code>和直接操作<code>SQlite数据库</code>。<br>由于CoreData底层的存储方式一般也都是<code>SQLite数据库</code>，因此，本文会详细了解<code>SQLite</code>底层原理及读写锁的控制，并尝试解释<code>CoreData多线程</code>到底做了什么。 </p>
<h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p>了解SQLite数据库之前先了解数据库的基本概念，包括什么是库，什么是表，SQL语句是什么</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>库相当于一个大的仓库。当我们想要使用仓库的时候就需要先建一个仓库。<br>创建<strong>数据库</strong>的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database xxx;</span><br></pre></td></tr></table></figure>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表相当于仓库里具体的一间库房。有的库房专门存放衣服，有的库房专门存放零食。<br>表由字段和记录组成。字段用于组织表结构（即组织库房结构），而记录就是根据字段来存放具体的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `CLOTHES` (</span><br><span class="line">  `key` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `value` char(255) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY (`k`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>
<p>上面就把表建好了。 key，value就是字段。<br>而真正的存放的每件衣服就是记录。</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p><code>SQL</code> 相当于我们给仓库管理员说的一句话。比如说我们想从1号仓库里的2号房间里拿出来型号为3的衣服。听到这么一句话，仓库管理员就可以行动了。<br><code>SQL</code>是我们同数据库打交道的指令。<br><code>SQL</code> 语句大致可以分为一下几类： </p>
<ul>
<li>数据定义（<code>SQL DDL</code>）用于定义SQL模式、基本表、视图、索引的创建和撤销操作</li>
<li>数据操纵 （<code>SQL DML</code>）数据操纵分成数据查询和数据更新两类。数据更新又分为插入、删除和修改三种操作。也就是我们所说的增删改查操作。</li>
<li>数据控制 （<code>DCL</code>）包括基本表的授权，完整性描述，事务控制等内容。</li>
</ul>
<h3 id="常见的数据库及应用场景"><a href="#常见的数据库及应用场景" class="headerlink" title="常见的数据库及应用场景"></a>常见的数据库及应用场景</h3><p>最常见的数据库模型主要是两种，即关系型数据库和非关系型数据库。</p>
<h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。<br>在服务端上有<code>Oracle</code>和<code>MySQL</code>。<br>在移动端里最常用的SQlite 就是关系型数据库。本文会对SQLite进行详细的解释。</p>
<h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p>非关系型数据库在超大规模和高并发的SNS类型的web2.0纯动态网站中有着非常好的性能。<br><code>NoSQL(NoSQL = Not Only SQL )</code>，意即“不仅仅是SQL”，  泛指非关系型数据库。<br>非关系型数据库 又分为键值存储数据库（key-value）(比如Redis数据库)、列存储（Column-oriented）数据库、面向文档（Document-Oriented）数据库、图形数据库。服务端特别互联网时代，对非关系行数据库有非常广泛的应用。 在移动端有代表性的是Realm。</p>
<h3 id="Sqlite"><a href="#Sqlite" class="headerlink" title="Sqlite"></a>Sqlite</h3><p><code>SQLite</code>，是一款轻型的数据库，是遵守<code>ACID</code>的关系型数据库管理系统。它的设计目标用于嵌入式系统，占用资源少，只需要几百K就够了，并且是跨平台的。目前主流的移动端操作系统Android和iOS的设备内置的都是SQLite数据库。</p>
<blockquote>
<p>ACID，是指数据库管理系统（<code>DBMS</code>）在写入或更新资料的过程中，为保证事务（<code>transaction</code>）是正确可靠的，所必须具备的四个特性：原子性（<code>atomicity</code>，或称不可分割性）、一致性（<code>consistency</code>）、隔离性（<code>isolation</code>，又称独立性）、持久性（<code>durability</code>）。 </p>
</blockquote>
<p>要想优化SQLite运行速度，必须要对SQLite的运行原理有所了解。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6232e5bc8731?w=315&amp;h=383&amp;f=jpeg&amp;s=44910" alt=""><br>它运行共分为4部分。Core层:包括接口层，编译器和虚拟机。 SQL编译层，包括语法分析，词法分析，代码生成。<code>Backend</code>层包括<code>B-Tree</code>、<code>Pager</code>，<code>OS</code>三部分，实现了数据库的主要存储逻辑。 <code>Accessories</code> 是辅助层，包括工具类和测试代码。 </p>
<p>比如一个对<code>Employee</code>表的数据操作流程如下：</p>
<p> 流程大致如下：  1. SQL语句 -&gt; 2.  触发磁盘I/O -&gt;3.磁盘返回一个表对应的<code>Index</code>表的一页Page，包含若干条记录 -&gt; 4. 在上述记录当中找到目标记录，如果没有找到满足条件的记录，则循环第2步骤和第3步骤 直到找到满足条件的记录-&gt; 5.根据<code>Index</code>表的记录里存放的<code>position</code>信息找到原始表记录的位置 -&gt;6.对原始表当中的目标记录进行操作，完成SQL操作。<br> 这里出现了几个名词：<code>Index</code>表和<code>原始表</code>，接下来会进行解释。 </p>
<h4 id="磁盘I-O瓶颈"><a href="#磁盘I-O瓶颈" class="headerlink" title="磁盘I/O瓶颈"></a>磁盘I/O瓶颈</h4><p>我们知道数据库文件其实是放在磁盘上的。而对磁盘的操作要比内存的操作要耗时的多。而一般情况下，一次查询往往无法通过一次I/O 操作完成。所以如何减少磁盘I/O 的次数成为我们优化<code>SQlite</code>性能的关键。 </p>
<h4 id="磁盘读取方式"><a href="#磁盘读取方式" class="headerlink" title="磁盘读取方式"></a>磁盘读取方式</h4><p>磁盘读取方式是以<code>Page</code>为单位。页（<code>page</code>）是计算机存储时，所使用的基础逻辑单位。内存和磁盘中的数据存储和交互都是以页为单位的。即使内存只需要1个字节的数据，从磁盘读取的时候也是拿到一个或多个<code>Page</code>，这是系统级别的一种预先缓存策略。 </p>
<h4 id="Index表"><a href="#Index表" class="headerlink" title="Index表"></a>Index表</h4><p>了解了磁盘I/O非常消耗性能后，我们可以看到如果一个Page里包含的记录比较多，那么SQL每次I/O被命中的概率就更大。 而如果要查询的是一个完整的表，比如一个表里有30个字段，一个字段占用100个字节，那么一个记录占用大概是 30 *100 = 3000 个这字节。假设一页 大小为 4KB，那么一页只存在一个记录。而假设我们使用一个表和原来的表做映射，但是只保留索引字段，比如说只保留key字段，和原始表对应的position字段，那么一页Page就可以装下100多个记录了。 这个和原始表对应的表就叫做<code>索引表</code>。 </p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>虽然二叉树可以实现log(n)的查找，和插入，但是由于二叉树的每个节点其实对应磁盘的一个<code>Page</code>。所以为了减少磁盘I/O 的次数，需要尽可能减少树的高度。而二叉树类似于一个高瘦的树，我们需要找到一个矮胖的树。 而B树正好符合这个性质。 <code>B树</code>是一个<code>多路查找平衡树</code>，他的每个节点最多包含k个孩子。 k被称为B树的<code>阶</code>。k的大小取决于磁盘页的大小。 </p>
<p><code>SQLite索引表</code>和原始表都是B树形式组织的。<br>也就说如果不建立<code>Index</code>表，原始表的每条记录的大小决定了<code>B树</code>的阶数。 阶数越大，B树越矮胖。<br>也就是要尽量减少原始表和<code>Index</code>表的大小。 尽量少用<code>string</code>类型，而用数值类型的字段。因为数值类型的字段占的字节少。</p>
<h4 id="SQlite-文件"><a href="#SQlite-文件" class="headerlink" title="SQlite 文件"></a>SQlite 文件</h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6240c86a4c4d?w=559&amp;h=366&amp;f=jpeg&amp;s=29584" alt=""><br><code>db</code>文件包括<code>.db</code> 文件,<code>.db_wal</code>文件和<code>.db_shm</code>文件。<br>其中<code>.db</code>文件是各个<code>table</code>存储的位置，原始表和索引表都在这个文件中。<br><code>.db_wal</code>是<code>_journal</code>文件的替代品。所有的事务会先提交到<code>wal</code>文件中，如果事务在写入<code>wal</code>过程中，失败，则把事务丢弃，否则就先存入<code>.db_wal</code>文件中。 然后在某个时机，比如<code>.db_wal</code>的文件达到了设定的阈值，（比如CoreData默认设置大约有4MB左右）会把<code>wal</code>的数据merge到<code>.db</code>文件中。 当然自己也可以手动merge。<br>利用<code>_wal</code>的好处是允许不同的连接，一个读<code>db</code>文件，另个写<code>wal</code>文件。 读和写可以并行。 读和读也可以并发，但是写操作和写操作不能并发。 这个和Sqlite多线程操作原理有关。<br> <code>_shm</code>文件是用来辅助<code>-wal</code>文件的。为了辅助<code>sqlite</code>快速定位<code>wal</code>文件信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e624597c2620e?w=561&amp;h=370&amp;f=jpeg&amp;s=25649" alt=""></p>
<h4 id="SQLite多线程"><a href="#SQLite多线程" class="headerlink" title="SQLite多线程"></a>SQLite多线程</h4><p><code>Sqlite</code>是支持多线程访问的。SQLite支持3种线程模式：</p>
<ol>
<li>单线程： 单线程下会禁用所有的<code>mutex</code>锁，并发使用时会出错。</li>
<li>多线程： 只要一个数据库连接不被多个线程同时使用，就是安全的。底层就是禁用数据库连接和<code>prepared statement</code>上的锁，实现多线程。因此不能在多个线程中并发使用同一个数据库连接和<code>prepared statement</code>。  </li>
<li>串行： 启用所有的锁，包括<code>bCoreMutex</code> 和 <code>bFullMutex</code> 。因为数据库连接和<code>prepared statement</code> 都已加锁，所以多线程使用这些对象时，没法并发，也就变成串行了。</li>
</ol>
<hr>
<blockquote>
<ul>
<li>数据库连接：  每次打开一次数据库，获取到的<code>database</code>就是一个数据库连接 </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static sqlite3 *openDb() &#123;</span><br><span class="line">    if (sqlite3_open(dbPath, &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSLog(@&quot;Failed to open database: %s&quot;, sqlite3_errmsg(database));</span><br><span class="line">    &#125;</span><br><span class="line">    return database;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Prepared statement</code> ,它是由数据库连接来管理的，使用它也可以看成使用这个数据库连接。 因此在多线程模式下，并发对同一个数据库连接调用<code>sqlite3_prepare_v2()</code>来创建<code>prepared statement</code>，或者对同一个数据库连接的任何<code>prepared statement</code> 并发的调用<code>sqlite3_blind_*()</code>和<code>sqlite3_step()</code>等函数会报错。 </li>
</ul>
</blockquote>
<p>SQLite标准发行版是<code>串行模式</code>，而iOS内置的SQLite库是<code>多线程模式</code>，python的sqlite是用串行模式。 </p>
<p>根据各种模式下线程安全的考虑，可以有四种访问数据库的模式可以选择： </p>
<ol>
<li>SQLite 使用单线程模式，用一个专门的线程访问数据库，需要线程间通讯，实现起来比较麻烦。</li>
<li>SQlite 使用单线程模式，用一个线程队列来访问数据库， 队列一次只允许一个线程执行，队列里的线程公用一个数据库连接。 可以使用<code>dispatch_queue_create()</code>来创建一个<code>serial queue</code>,来作为队列。</li>
<li>SQLite使用多线程模式，每个线程创建自己的数据库连接。<br>这种情况需要每次都要打开和关闭数据库连接，所以会额外消耗一些时间。这种情况可以选用一个<code>并发队列</code>。每次读写的时候都要开启和关闭数据库连接 。</li>
<li>SQLite使用串行模式，所有的线程公用全局的数据库连接<br><code>SQLite</code>的串行模式相当于让<code>SQlite</code>自己来维护队列，只不过SQL的执行是乱序的，因此无法保证事务性。 </li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e624d3b5f2601?w=363&amp;h=350&amp;f=jpeg&amp;s=46302" alt=""></p>
<h4 id="FMDB多线程"><a href="#FMDB多线程" class="headerlink" title="FMDB多线程"></a>FMDB多线程</h4><p><code>FMDB</code>是用于数据存储的框架。它是iOS平台下对<code>SQLite</code>数据的封装，<code>FMDB</code>是面向对象的，它以OC语言封装了<code>SQLite</code>的C语言的API，使用起来非常方便。是iOS平台上使用最多的第三方数据存储框架。 </p>
<p>FMDB使用iOS官方的SQLite库，也就是默认模式是多线程模式。</p>
<p>FMDB中对多线程的管理是用串行队列来完成的。用 <code>FMDatabaseQueue</code>来管理这个队列。<br><code>FMDatabaseQueue</code>初始化的时候，初始化了一个串行队列，并给其添加唯一标识： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</span><br><span class="line">        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);</span><br></pre></td></tr></table></figure>
<p>而当操作数据库的时候，使用了这个串行队列并且同步执行。这样能够保证一个数据库连接在同一时刻只有一个事务在操作数据库。就满足了SQLite数据库同一时刻不能有多个操作的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_sync(_queue, ^() &#123;</span><br><span class="line">     ///数据库操作</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>一个FMDatabaseQueue就是一个串行队列。就算你开启多线程执行，它依然还是串行执行的。保证了线程的安全性。</p>
<p>如果想实现多个线程操作数据库，可以创建多个<code>FMDatabaseQueue</code> ，虽然每个<code>queue</code>内部是串行运行的，但是<code>queue</code>与<code>queue</code>可以并发执行。 </p>
<p><code>FMDB</code>使用了一个串行队列，并且同步执行，假如这个串行队列中有两个任务，任务1先开始，任务1依赖于任务2的执行结果，任务2需要等待任务1执行完，才开始执行，那么就会出现死锁。所以在使用FMDB的时候一定要注意，尽量不要在任务中嵌套使用 。<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6270e081c964?w=800&amp;h=514&amp;f=jpeg&amp;s=107050" alt=""></p>
<h4 id="Core-Data多线程"><a href="#Core-Data多线程" class="headerlink" title="Core Data多线程"></a>Core Data多线程</h4><p><code>Core Data</code> 是苹果官方推出的数据持久化框架。它类似与<code>ORM</code>（对象关系映射），但是要比ORM做的更多。<code>Core Data</code>存储一般选用<code>SQLite</code>数据库作为持久化存储区，但是也可以选用二进制，XML等形式的持久化存储。<br>在使用SQLite的时候，<code>CoreData</code> 默认是开启多线程模式的。<br>从<code>NSManagedObjectContext</code>不能跨线程使用来看，<code>Core Data</code>在实现上可能是一个<code>MOC</code>对象对应着一个数据库连接。 所以建立连接的时候有如下规定：</p>
<ul>
<li>不同的线程要建立自己的<code>NSManagedObjectContext</code>，维护自己的对象。 </li>
<li><p><code>NSManagedObject</code> 对象不能跨线程使用。 </p>
<p>由于数据库操作的时候，不能跨线程，并且需要同步，为了防止死锁等问题，现有比较好的解决方案是利用三层<code>NSManagedObjectContext</code> 来操作数据库。 </p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e628810d2ab34?w=856&amp;h=735&amp;f=jpeg&amp;s=128002" alt=""></p>
<p>MOC 可以设置<code>parentContext</code> ,一个<code>parentContext</code>可以拥有多个<code>childContext</code>，在<code>childContext</code>执行的<code>Save</code>操作，会将操作<code>push</code>到<code>parentContext</code>中，由<code>parentContext</code>来执行真正的<code>save</code>操作。而<code>childContext</code>的所有改变会被<code>parentContontext</code>知晓。 这样解决了手动同步的问题。 </p>
<p>三层模型可以让我们在<code>MainContext</code>里执行UI相关的操作，而保存操作会在子线程 <code>Context</code>中，子线程是后台线程，当执行save的时候，会把状态保存到<code>MainContext</code> 中，<code>MainContext</code> 再次<code>save</code> 的时候，会把状态保存到最上层的唯一的私有<code>context</code>中。当<code>最上层的context</code>执行了save，才会真正触发执行把数据保存到数据库中的操作。 由于最上层的操作，是在子线程进行的，所以不会影响UI。<br>这里需要注意的是最下面的子线程 <code>Context</code>可以有多个。并且应用原则应该是用完即扔，不用保存这个<code>Context</code>。这样不会导致<code>Context</code>混乱的问题。 子Context之间不用进行通讯，意义不大，还会惹出一堆问题。我们的<code>MainContext</code>全程只有一个，用来进行UI相关的操作。并且最上层的私有context也是唯一一个。这就保证了我们只有一个数据库连接。<br>这样以后，其实是人为的保证了最上层只有一个<code>Context</code> 在和数据库打交到。 而这个<code>Context</code>又是在单个线程下的。所以能够保证对SQLite的操作是能满足多线程模式的要求的。<br>然而也可以看出，这样的操作，并没有发挥出多线程模式的优势来。有点类似于串行模式。<br>但是这样能够保证线程安全，并且不会阻塞主线程。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>iOS端的存储方案有很多。到底选择哪种存储方案，还是要依赖于当时的业务场景出发。本文大体介绍了各种存储方式的原理，进而来探讨各个方案优劣点，及使用场景。 并没有对各个方案的实现细节有太多的描述。文件存储方案实现简单，在较简单的场景下非常有用。 数据库存储适合比较复杂的业务场景。当然坑也非常多，也有很多技术难点，在接下的文章中我们会对<code>FMDB</code>，<code>CoreData</code>进行详细的探讨。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p><a href="http://www.jianshu.com/p/cf76e2e81230" target="_blank" rel="noopener">iOS进阶——SQLite数据库</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/stephen-liu74/archive/2012/03/02/2328753.html" target="_blank" rel="noopener">SQLite学习手册(锁和并发控制)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/107c6b045245" target="_blank" rel="noopener">超全的数据库分类介绍</a></p>
</li>
<li><p><a href="http://blog.csdn.net/zhoudaxia/article/details/8196838" target="_blank" rel="noopener">SQLite剖析(5)：体系结构</a></p>
</li>
<li><p><a href="https://www.keakon.net/2011/10/25/SQLite%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">SQLite在多线程环境下的应用</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286361&amp;idx=1&amp;sn=78bbcda7f41a14291ad71289e4821f71&amp;scene=21" target="_blank" rel="noopener">微信iOS SQLite源码优化实践</a></p>
<ul>
<li><a href="http://blog.csdn.net/yixiangboy/article/details/51274189" target="_blank" rel="noopener">IOS开发源码阅读篇–FMDB源码分析3</a></li>
</ul>
</li>
<li><p><a href="http://blog.flight.dev.qunar.com/2016/11/10/ios-data-persistence-learn/" target="_blank" rel="noopener">iOS 中数据持久化的几种方式</a></p>
</li>
</ul>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/06/25/如何更改-Mac-文件的默认打开方式/" rel="next" title="如何更改 Mac 文件的默认打开方式">
                <i class="fa fa-chevron-left"></i> 如何更改 Mac 文件的默认打开方式
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/06/25/AFNetworkReachabilityManager源码解析/" rel="prev" title="AFNetworkReachabilityManager源码解析及网络监控相关分析">
                AFNetworkReachabilityManager源码解析及网络监控相关分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar1.jpg"
                alt="liujunlong" />
            
              <p class="site-author-name" itemprop="name">liujunlong</p>
              <p class="site-description motion-element" itemprop="description">记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#iOS-存储方案从入门到精通"><span class="nav-number">1.</span> <span class="nav-text">iOS 存储方案从入门到精通</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引导语"><span class="nav-number">1.1.</span> <span class="nav-text">引导语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存存储"><span class="nav-number">1.2.</span> <span class="nav-text">内存存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘存储"><span class="nav-number">1.3.</span> <span class="nav-text">磁盘存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘存储方式的选择"><span class="nav-number">1.3.1.</span> <span class="nav-text">磁盘存储方式的选择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统管理方式"><span class="nav-number">1.3.2.</span> <span class="nav-text">文件系统管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#plist文件"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">plist文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSUserDefaults存储"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">NSUserDefaults存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyChain"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">KeyChain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSKeyedArchiver"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">NSKeyedArchiver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件-存储"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">文件 存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#感悟"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">感悟</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库"><span class="nav-number">1.4.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库基本概念"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据库基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#库"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">SQL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的数据库及应用场景"><span class="nav-number">1.4.2.</span> <span class="nav-text">常见的数据库及应用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关系型数据库"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非关系型数据库"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">非关系型数据库</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sqlite"><span class="nav-number">1.4.3.</span> <span class="nav-text">Sqlite</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘I-O瓶颈"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">磁盘I/O瓶颈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘读取方式"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">磁盘读取方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Index表"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Index表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B树"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQlite-文件"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">SQlite 文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQLite多线程"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">SQLite多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FMDB多线程"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">FMDB多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Core-Data多线程"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">Core Data多线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束语"><span class="nav-number">1.5.</span> <span class="nav-text">结束语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考链接"><span class="nav-number">1.6.</span> <span class="nav-text">参考链接</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liujunlong</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>



<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共11.6k字</span>
</div>

        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  













  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
