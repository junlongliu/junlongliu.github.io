<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
<meta property="og:type" content="website">
<meta property="og:title" content="junlong的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="junlong的博客">
<meta property="og:description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="junlong的博客">
<meta name="twitter:description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>junlong的博客</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">junlong的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">热爱技术，热爱生活</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/25/AFNetworkReachabilityManager源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujunlong">
      <meta itemprop="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junlong的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/AFNetworkReachabilityManager源码解析/" itemprop="url">
                  AFNetworkReachabilityManager源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-25 21:20:42" itemprop="dateCreated datePublished" datetime="2018-06-25T21:20:42+08:00">2018-06-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-07-02 21:41:29" itemprop="dateModified" datetime="2018-07-02T21:41:29+08:00">2018-07-02</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://imageliujunlong.test.upcdn.net/2018/07/02/连接.jpg" alt="连接"></p>
<h1 id="AFNetworking-AFNetworkReachabilityManager-网路状态监控"><a href="#AFNetworking-AFNetworkReachabilityManager-网路状态监控" class="headerlink" title="AFNetworking - AFNetworkReachabilityManager  网路状态监控"></a>AFNetworking - AFNetworkReachabilityManager  网路状态监控</h1><p>在很多业务场景下，需要判断网络的状态。 苹果本身给我们提供了系统API : <code>SCNetworkReachabilityRef</code>。但是使用起来比较繁琐，有开源的项目对它进行了封装。 比如<code>AFNetworkReachabilityManager</code> 、 <code>Reachability</code>等。 但是他们的原理都是相似的。 首先我们来看一下网络监控的原理。 </p>
<h2 id="网络状态监控原理"><a href="#网络状态监控原理" class="headerlink" title="网络状态监控原理"></a>网络状态监控原理</h2><p>其实原理还是比较简单的 ： 判断一个网络的状态，可以通过尝试进行sockete通讯，通过查看得到的响应状态来判断。 所以首先要有 <code>SCNetworkReachabilityRef</code> ，这个指明了<code>socket</code>要连接的类型：是<code>IPV6</code> 还是<code>IPV4</code> ，端口号是多少以及要连接的IP地址等。 然后通过苹果内部实现网络连接会返回<code>SCNetworkReachabilityFlags</code> 来标明网络状态。这样便实现了从而来进行网络状态的监控。 </p>
<p><img src="http://imageliujunlong.test.upcdn.net/2018/07/02/Socket连接.png" alt="Socket连接"></p>
<h2 id="网络状态监控实现"><a href="#网络状态监控实现" class="headerlink" title="网络状态监控实现"></a>网络状态监控实现</h2><p>我们从使用角度上来分析网络状态监控实现 的实现细节。 可以分为两步： </p>
<ul>
<li>初始化 AFNetworkReachabilityManager </li>
<li>调用 startMonitoring 方法开始对网络状态进行监控 </li>
</ul>
<h3 id="AFNetworkReachabilityManager-的初始化"><a href="#AFNetworkReachabilityManager-的初始化" class="headerlink" title="AFNetworkReachabilityManager 的初始化"></a>AFNetworkReachabilityManager 的初始化</h3><p>AFNetworkReachabilityManager 初始化的除了创建单例类，剩下的主要目的是要创建SCNetworkReachabilityRef 。所以创建SCNetworkReachabilityRef的三种方式也就是初始化AFNetworkReachabilityManager的三种方式。</p>
<blockquote>
<p>socket 描述符<br>socket 主要用于运行在不同服务器上的进程之间通信，也可以用于在同一服务器上的进程之间通信。<br>socket 描述符则是 socket 的唯一标识，其本质是一种特殊的文件描述符。</p>
</blockquote>
<ul>
<li>给定socket描述符来创建<br>这时sockaddr 是给定的，则可以通过下面的方法来创建SCNetworkReachabilityRef </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SCNetworkReachabilityRef reachability = </span><br><span class="line">SCNetworkReachabilityCreateWithAddress(kCFAllocatorDefault, (const struct sockaddr *)address);</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* 给定域名来进行创建 </span><br><span class="line">给定domain，也就是域名字符串。来创建SCNetworkReachabilityRef。 </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> SCNetworkReachabilityRef reachability = </span><br><span class="line"> SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</span><br></pre></td></tr></table></figure>
<ul>
<li>没有给定socket描述符，则创建默认的 sockaddr_in6</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in6 address;</span><br><span class="line">bzero(&amp;address, sizeof(address));</span><br><span class="line">address.sin6_len = sizeof(address);</span><br><span class="line">address.sin6_family = AF_INET6;</span><br></pre></td></tr></table></figure>
<p>这个sockaddr_in6会被被初始化为0 。指定地址类型是<code>IPV4</code> ,还是<code>IPV6</code> 。这里指定为AF_INET6 ，即IPV6。<br>在 <code>IPV4</code> 中， 没有指定<code>sin6_addr</code> 则会初始化为<code>0.0.0.0</code>   。在路由表中，<code>0.0.0.0</code>表示的是默认路由，即当路由表中没有找到完全匹配的路由的时候所对应的路由。 </p>
<h3 id="调用-startMonitoring-方法开始对网络状态进行监控"><a href="#调用-startMonitoring-方法开始对网络状态进行监控" class="headerlink" title="调用 startMonitoring 方法开始对网络状态进行监控"></a>调用 startMonitoring 方法开始对网络状态进行监控</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</span><br><span class="line">  SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line">  SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</span><br><span class="line">      SCNetworkReachabilityFlags flags;</span><br><span class="line">      if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</span><br><span class="line">          AFPostReachabilityStatusChange(flags, callback);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>首先指定<code>SCNetworkReachabilityContext</code> 上下文。 其次设置网络状态回调<code>SCNetworkReachabilitySetCallback</code>。 然后把<code>SCNetworkReachabilityRef</code> 设置到<code>main runloop</code> 下，并且指定<code>mode</code> 为 <code>kCFRunLoopCommonModes</code> 。 最后通过<code>SCNetworkReachabilityGetFlags</code>来获取网络状态。 如果网络状态变化，则调用<code>AFPostReachabilityStatusChange</code> 执行回调，抛出通知。 </p>
<p>下面我们依次看一下这些函数具体是什么含义，如何使用。 </p>
<h4 id="SCNetworkReachabilityContext-上下文"><a href="#SCNetworkReachabilityContext-上下文" class="headerlink" title="SCNetworkReachabilityContext 上下文"></a>SCNetworkReachabilityContext 上下文</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">	CFIndex		version; //当前结构体的版本号</span><br><span class="line">	void *		__nullable info; //用户指定用于回到的block，</span><br><span class="line">	const void	* __nonnull (* __nullable retain)(const void *info); //对上面的info block进行 retain </span><br><span class="line">	void		(* __nullable release)(const void *info);// 对上面的info block进行 release  </span><br><span class="line">	CFStringRef	__nonnull (* __nullable copyDescription)(const void *info); //对 info block 的字符说明</span><br><span class="line">&#125; SCNetworkReachabilityContext;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>SCNetworkReachabilityContext</code> 主要声明了 <code>SCNetworkReachability</code>的回调。也就是网络发生变化时的回调。当网络可达性发生变化时，会执行上面的<code>info</code>回调。 </p>
<p>来看一下<code>AFNetworkReachabilityManager</code> 是如何使用的 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static const void * AFNetworkReachabilityRetainCallback(const void *info) &#123;</span><br><span class="line">    return Block_copy(info);</span><br><span class="line">&#125;</span><br><span class="line">static void AFNetworkReachabilityReleaseCallback(const void *info) &#123;</span><br><span class="line">    if (info) &#123;</span><br><span class="line">        Block_release(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">        strongSelf.networkReachabilityStatus = status;</span><br><span class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">            strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</span><br></pre></td></tr></table></figure>
<p><code>callback</code> 用来把状态信息传给<code>strongSelf.networkReachabilityStatusBlock</code> 。 而<code>AFNetworkReachabilityRetainCallback</code> 则是对<code>info</code> 这个<code>block</code>进行<code>copy</code>操作。<br><code>AFNetworkReachabilityReleaseCallback</code>对 <code>info</code> 这个<code>block</code>进行<code>release</code>操作。描述信息设置为了<code>NULL</code> 。这样创建了一个context，info信息用来回调<code>strongSelf.networkReachabilityStatusBlock</code>。  当info执行的回调的时候，会调用<code>strongSelf.networkReachabilityStatusBlock</code>。<br>而<code>networkReachabilityStatusBlock</code> 就是我们外部观测网络状态变化的block。 我们可以在这个block 里执行一些网络状态变化后需要执行的操作。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void (^AFNetworkReachabilityStatusBlock)(AFNetworkReachabilityStatus status);</span><br></pre></td></tr></table></figure>
<h4 id="SCNetworkReachabilitySetCallback"><a href="#SCNetworkReachabilitySetCallback" class="headerlink" title="SCNetworkReachabilitySetCallback"></a>SCNetworkReachabilitySetCallback</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Boolean</span><br><span class="line">SCNetworkReachabilitySetCallback		(</span><br><span class="line">						SCNetworkReachabilityRef			target, </span><br><span class="line">						SCNetworkReachabilityCallBack	__nullable	callout,</span><br><span class="line">						SCNetworkReachabilityContext	* __nullable	context</span><br><span class="line">						)</span><br></pre></td></tr></table></figure>
<p>这个方法的第二个参数<code>SCNetworkReachabilityCallBack</code> ，用来指定网络状态发生变化后这个<code>callback</code>会执行。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*SCNetworkReachabilityCallBack)	(</span><br><span class="line">						SCNetworkReachabilityRef			target,</span><br><span class="line">						SCNetworkReachabilityFlags			flags,</span><br><span class="line">						void			     *	__nullable	info</span><br><span class="line">						);</span><br></pre></td></tr></table></figure>
<p>其中的info同<code>SCNetworkReachabilityContext</code>的info。 指明当网络发生变化时执行的info。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</span><br><span class="line"></span><br><span class="line">static void AFNetworkReachabilityCallback(SCNetworkReachabilityRef __unused target, SCNetworkReachabilityFlags flags, void *info) &#123;</span><br><span class="line">    AFPostReachabilityStatusChange(flags, (__bridge AFNetworkReachabilityStatusBlock)info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>AFNetworkReachabilityManager</code> 声明<code>SCNetworkReachabilityCallBack</code> 为 <code>AFNetworkReachabilityCallback</code> 。 </p>
<p> <code>AFNetworkReachabilityCallback</code> 会调用<code>AFPostReachabilityStatusChange</code> 。在<code>AFPostReachabilityStatusChange</code> 函数里，会调用<code>AFNetworkReachabilityStatusForFlags</code> 函数 ，该函数会将得的<code>SCNetworkReachabilityFlags</code> 转换为<code>AFNetworkReachabilityStatus</code> ，然后执行状态变化回调，并且为发出通知。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void AFPostReachabilityStatusChange(SCNetworkReachabilityFlags flags, AFNetworkReachabilityStatusBlock block) &#123;</span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusForFlags(flags);</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        if (block) &#123;</span><br><span class="line">            block(status);</span><br><span class="line">        &#125;</span><br><span class="line">        NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</span><br><span class="line">        NSDictionary *userInfo = @&#123; AFNetworkingReachabilityNotificationStatusItem: @(status) &#125;;</span><br><span class="line">        [notificationCenter postNotificationName:AFNetworkingReachabilityDidChangeNotification object:nil userInfo:userInfo];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AFStringFromNetworkReachabilityStatus-状态的转换"><a href="#AFStringFromNetworkReachabilityStatus-状态的转换" class="headerlink" title="AFStringFromNetworkReachabilityStatus 状态的转换"></a>AFStringFromNetworkReachabilityStatus 状态的转换</h4><p><code>AFNetworkReachabilityStatusForFlags</code> 为网络状态函数。该函数主要是将<code>SCNetworkReachabilityFlags</code> 的标记转换为AF自己定义的标记<code>AFNetworkReachabilityStatus</code> 。<br>而<code>SCNetworkReachabilityFlags</code> 主要状态如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef CF_OPTIONS(uint32_t, SCNetworkReachabilityFlags) &#123;</span><br><span class="line">	kSCNetworkReachabilityFlagsTransientConnection	= 1&lt;&lt;0, 标明指定的节点或地址是联通的</span><br><span class="line">	kSCNetworkReachabilityFlagsReachable		= 1&lt;&lt;1,指明利用现在的网络配置是联通的</span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionRequired	= 1&lt;&lt;2,// 指明当前网络通过制定的节点或地址是可以联通的，但是需要先建立连接</span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionOnTraffic	= 1&lt;&lt;3,//指明当前连接是可以联通的，但是需要指明路由到指定节点</span><br><span class="line">	kSCNetworkReachabilityFlagsInterventionRequired	= 1&lt;&lt;4,// 指明当前连接是可以联通的，但是需要先建立连接，另外，一些形式的用户交互需要来建立连接，比如提供密码，认证token等。	kSCNetworkReachabilityFlagsConnectionOnDemand	= 1&lt;&lt;5,	// 指明当前连接是可以联通的，但是需要先建立连接，连接需要通过CFSocketStream 的 API 来建立连接。</span><br><span class="line">	__OSX_AVAILABLE_STARTING(__MAC_10_6,__IPHONE_3_0)</span><br><span class="line">	kSCNetworkReachabilityFlagsIsLocalAddress	= 1&lt;&lt;16, 表示当前节点或地址是当前系统的本地接口</span><br><span class="line">	kSCNetworkReachabilityFlagsIsDirect		= 1&lt;&lt;17, 表明指定的网络节点或地址不能通过网关，但是能直接到达系统的接口</span><br><span class="line">#if	TARGET_OS_IPHONE</span><br><span class="line">	kSCNetworkReachabilityFlagsIsWWAN		= 1&lt;&lt;18,//表示指定的节点或地址能够通过GRPS，EDGE或其他蜂窝连接。</span><br><span class="line">#endif	// TARGET_OS_IPHONE</span><br><span class="line"></span><br><span class="line">	kSCNetworkReachabilityFlagsConnectionAutomatic	= kSCNetworkReachabilityFlagsConnectionOnTraffic</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>来看一下<code>AFNetworkReachabilityStatusForFlags</code> 是如何进行转换的： </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static AFNetworkReachabilityStatus AFNetworkReachabilityStatusForFlags(SCNetworkReachabilityFlags flags) &#123;</span><br><span class="line">    BOOL isReachable = ((flags &amp; kSCNetworkReachabilityFlagsReachable) != 0);</span><br><span class="line">    BOOL needsConnection = ((flags &amp; kSCNetworkReachabilityFlagsConnectionRequired) != 0);</span><br><span class="line">    BOOL canConnectionAutomatically = (((flags &amp; kSCNetworkReachabilityFlagsConnectionOnDemand ) != 0) || ((flags &amp; kSCNetworkReachabilityFlagsConnectionOnTraffic) != 0));</span><br><span class="line">    BOOL canConnectWithoutUserInteraction = (canConnectionAutomatically &amp;&amp; (flags &amp; kSCNetworkReachabilityFlagsInterventionRequired) == 0);</span><br><span class="line">    BOOL isNetworkReachable = (isReachable &amp;&amp; (!needsConnection || canConnectWithoutUserInteraction));</span><br><span class="line"></span><br><span class="line">    AFNetworkReachabilityStatus status = AFNetworkReachabilityStatusUnknown;</span><br><span class="line">    if (isNetworkReachable == NO) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusNotReachable;</span><br><span class="line">    &#125;</span><br><span class="line">#if	TARGET_OS_IPHONE</span><br><span class="line">    else if ((flags &amp; kSCNetworkReachabilityFlagsIsWWAN) != 0) &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWWAN;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">    else &#123;</span><br><span class="line">        status = AFNetworkReachabilityStatusReachableViaWiFi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>AFNetworkReachabilityStatusForFlags</code> 函数利用了<code>SCNetworkReachabilityFlags</code>的各种标记，先通过<code>kSCNetworkReachabilityFlagsReachable</code> 、<code>kSCNetworkReachabilityFlagsConnectionRequired</code> 、<code>kSCNetworkReachabilityFlagsConnectionOnDemand</code>、 <code>kSCNetworkReachabilityFlagsConnectionOnTraffic</code>、<code>kSCNetworkReachabilityFlagsInterventionRequired</code> 来判断出是否连通。如果不连通，则直接赋值为无连接，否则通过<code>kSCNetworkReachabilityFlagsIsWWAN</code>来判断是否是蜂窝连接，如果可以连通且不是蜂窝连接，则认为是<code>Wifi</code>。</p>
<h4 id="SCNetworkReachabilityScheduleWithRunLoop"><a href="#SCNetworkReachabilityScheduleWithRunLoop" class="headerlink" title="SCNetworkReachabilityScheduleWithRunLoop"></a>SCNetworkReachabilityScheduleWithRunLoop</h4><p>  这个函数主要将<code>networkReachability</code> 设置在 <code>main runloop</code> 中，并且为<code>runloop</code> 的<code>mode</code> 为<code>kCFRunLoopCommonModes</code> 。 设置完这个以后监听就开始运作了。 </p>
<h4 id="SCNetworkReachabilityGetFlags"><a href="#SCNetworkReachabilityGetFlags" class="headerlink" title="SCNetworkReachabilityGetFlags"></a>SCNetworkReachabilityGetFlags</h4><p>当网络获取到状态的时候立刻执行 <code>AFPostReachabilityStatusChange</code> 来发出通知，执行回调。  </p>
<h1 id="YYReachability-所具有的能力"><a href="#YYReachability-所具有的能力" class="headerlink" title="YYReachability 所具有的能力"></a>YYReachability 所具有的能力</h1><p><code>YYReachability</code> 具有和<code>AFNetworkReachabilityManager</code> 同样的能力，两者实现的原理也完全相同，但是<code>YYReachability</code> 可以区分出蜂窝连接是2G，3G，4G。<br>我们来一下它是如何实现的。<br>首先看一下他的各种状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, YYReachabilityWWANStatus) &#123;</span><br><span class="line">    YYReachabilityWWANStatusNone  = 0, ///&lt; Not Reachable vis WWAN</span><br><span class="line">    YYReachabilityWWANStatus2G = 2, ///&lt; Reachable via 2G (GPRS/EDGE)       10~100Kbps</span><br><span class="line">    YYReachabilityWWANStatus3G = 3, ///&lt; Reachable via 3G (WCDMA/HSDPA/...) 1~10Mbps</span><br><span class="line">    YYReachabilityWWANStatus4G = 4, ///&lt; Reachable via 4G (eHRPD/LTE)       100Mbps</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过YYReachabilityStatusFromFlags 函数 将得到的SCNetworkReachabilityFlags 转化为 <code></code>YYReachabilityWWANStatus 。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (YYReachabilityStatus)status &#123;</span><br><span class="line">    return YYReachabilityStatusFromFlags(self.flags, self.allowWWAN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CTTelephonyNetworkInfo</code> 来得到电话服务接入的点。<br><code>CTTelephonyNetworkInfo</code> 里有属性<code>currentRadioAccessTechnology</code> 指明了当前的无线接入技术。 下面的 dic 则表明了各种无线接入技术所对应的<code>YYReachabilityWWANStatus</code> ，从而来获取wwan接入的蜂窝网络具体是什么。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NSString *status = self.networkInfo.currentRadioAccessTechnology;</span><br><span class="line">   if (!status) return YYReachabilityWWANStatusNone;</span><br><span class="line">   static NSDictionary *dic;</span><br><span class="line">   static dispatch_once_t onceToken;</span><br><span class="line">   dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">       dic = @&#123;CTRadioAccessTechnologyGPRS : @(YYReachabilityWWANStatus2G),  // 2.5G   171Kbps</span><br><span class="line">               CTRadioAccessTechnologyEdge : @(YYReachabilityWWANStatus2G),  // 2.75G  384Kbps</span><br><span class="line">               CTRadioAccessTechnologyWCDMA : @(YYReachabilityWWANStatus3G), // 3G     3.6Mbps/384Kbps</span><br><span class="line">               CTRadioAccessTechnologyHSDPA : @(YYReachabilityWWANStatus3G), // 3.5G   14.4Mbps/384Kbps</span><br><span class="line">               CTRadioAccessTechnologyHSUPA : @(YYReachabilityWWANStatus3G), // 3.75G  14.4Mbps/5.76Mbps</span><br><span class="line">               CTRadioAccessTechnologyCDMA1x : @(YYReachabilityWWANStatus3G), // 2.5G</span><br><span class="line">               CTRadioAccessTechnologyCDMAEVDORev0 : @(YYReachabilityWWANStatus3G),</span><br><span class="line">               CTRadioAccessTechnologyCDMAEVDORevA : @(YYReachabilityWWANStatus3G),</span><br><span class="line">               CTRadioAccessTechnologyCDMAEVDORevB : @(YYReachabilityWWANStatus3G),</span><br><span class="line">               CTRadioAccessTechnologyeHRPD : @(YYReachabilityWWANStatus3G),</span><br><span class="line">               CTRadioAccessTechnologyLTE : @(YYReachabilityWWANStatus4G)&#125;; // LTE:3.9G 150M/75M  LTE-Advanced:4G 300M/150M</span><br><span class="line">   &#125;);</span><br><span class="line">   NSNumber *num = dic[status];</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/25/iOS-存储方案从入门到精通/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujunlong">
      <meta itemprop="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junlong的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/iOS-存储方案从入门到精通/" itemprop="url">
                  iOS 存储方案从入门到精通
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-25 20:56:04 / Modified: 21:01:11" itemprop="dateCreated datePublished" datetime="2018-06-25T20:56:04+08:00">2018-06-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-存储方案从入门到精通"><a href="#iOS-存储方案从入门到精通" class="headerlink" title="iOS 存储方案从入门到精通"></a>iOS 存储方案从入门到精通</h1><h2 id="引导语"><a href="#引导语" class="headerlink" title="引导语"></a>引导语</h2><p>在业务开发过程中，对于数据的处理，总是占有很大一部分时间。而又根据不同的业务需要，存储方案可以进行不同的选择。从数据存储的位置角度来分的话，存储可以分为内存存储和硬盘存储。内存存储，数据交互快，在一些需要复杂耗时的地方可以考虑内存缓存来解决。而磁盘存储，由于磁盘本身的特点，当触发操作时，需要一些磁盘变道等物理操作，交互速度会大大降低，但是由于可以保存大量数据，数据可以一直持有，可以在app被关闭后，数据可以重新被加载到程序中，所以在iOS端也提供了非常多的方式来把数据保存到磁盘。</p>
<p>在接下来的内容中，我会分别介绍内存存储和磁盘存储的适用场景，由于内存存储比较简单，所以重点会放在磁盘存储空间上。而磁盘存储又可以分为文件系统和数据库系统，而数据库系统也是我们在业务中遇到问题最多的地方，所以在简单介绍文件系统的相关适用场景及各个文件存储方案的原理及优劣后，会花大量篇幅介绍数据库系统，而数据库系统，在移动端的解决方案中，<code>SQLite</code>数据库的解决方案也是应用最为广泛的。我会介绍<code>SQLite</code>的相关原理，以此来探究一些性能问题。由于多线程操作一直很神秘，也经常容易出错，所以从<code>SQLite</code>底层的角度来一探究竟。</p>
<h2 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h2><p>内存存储也可以称为内存缓存，因为内存存储的数据只保留在APP启动时。比如保存一些从服务端获取到的数据，来缓解服务器的压力，并且节约了用户流量和时间，提高了用户使用体验。<code>NSURLConnection</code>默认会缓存资源在内存。内存缓存还可以保留一些处理好的数据，比如Feed流把处理好的数据存储到内存缓存中，等到再次使用的时候直接从缓存中取。常见的内存缓存框架有<code>NSCache</code>、<code>TMMemoryCache</code>、<code>PINMemoryCache</code>、<code>YYMemoryCache</code>。<code>NSCache</code> 是苹果提供的一个简单的内存缓存，它有着和 <code>NSDictionary</code> 类似的 API，不同点是它是线程安全的。<code>YYMemoryCache</code> 缓存内部用<code>双向链表</code>和 <code>NSDictionary</code> 实现了 <code>LRU 淘汰算法</code>(Least recently used，最近最少使用)。<br>一般内存缓存的大致流程如下所示： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e61f870b4d551?w=1178&amp;h=508&amp;f=jpeg&amp;s=86243" alt=""></p>
<ol>
<li>APP会优先请求内存缓冲中的资源</li>
<li>如果内存缓冲中有，则直接返回资源文件， 如果没有的话，则会请求资源文件，这时资源文件可能存储在服务端，需要进行网络请求获取，也可以是本地文件，需要操作文件系统或数据库来获取。</li>
<li>获取到的资源文件，先缓存到内存缓存，方便以后不再重复获取，节省时间。</li>
<li>然后就是从缓存中取到数据然后给app使用。</li>
</ol>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><p>内存存储适合存储一些app高频次使用，并且所占空间不大的文件。而磁盘存储则可以存储一些需要持久化的文件，信息等。简单的讲就是app被杀死以后，文件仍然在。而磁盘存储根据数据管理方式又可以分为两大类：文件系统存储和数据库系统存储。<br>文件系统把数据组织成相互独立的数据文件。实现了记录内部结构性，但整体无结构。而数据库系统实现了整体数据的结构化。<br>数据库系统主要管理数据库的存储，事务，以及对数据库的操作。而文件系统是操作系统管理文件和存储空间的子系统。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e620bfaf41c70?w=948&amp;h=528&amp;f=jpeg&amp;s=44196" alt=""></p>
<h3 id="磁盘存储方式的选择"><a href="#磁盘存储方式的选择" class="headerlink" title="磁盘存储方式的选择"></a>磁盘存储方式的选择</h3><p>根据操作系统和文件系统的特点，假如存储的数据是结构化的，想要易于统计分析，那么就可以选择数据库来存储。如果存储数据结构单一，并且可能单个数据量大，则可以使用文件系统管理。<br>比如说在百度音乐app内，歌曲信息包含歌曲播放链接，歌曲名，歌手名，所属专辑等信息，这些信息数据量小，但是结构化，并且对于所有的歌曲要进行频繁的统计，和比较细粒度的数据处理。那么就非常适合用数据库来管理。而下载到本地的歌曲，下载到本地的视频等信息，则非常适合用文件管理系统来存储数据。</p>
<h3 id="文件系统管理方式"><a href="#文件系统管理方式" class="headerlink" title="文件系统管理方式"></a>文件系统管理方式</h3><p>文件系统是操作系统管理文件和存储空间的子程序。在iOS系统中还提供了一些文件存储方案。<br>存储方案有<code>plist文件存储</code>，<code>NSUserDefalut存储</code>，<code>keyChain存储</code>，<code>NSKeyedArchiver</code>（序列化存储）。<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6216b22b30bd?w=557&amp;h=199&amp;f=jpeg&amp;s=23215" alt=""></p>
<h4 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h4><p><code>plist文件</code>通常用来存储用户设置，还可以存储程序中经常用到而不经常改动的数据。比如一个app内部常用的颜色，配置信息，可以存储在<code>plist</code>中。结构清晰，易于查找。<br>plist文件是一种存储串行化后的对象文件。文件格式是XML的。plist文件可以通过系统的方法进行读取，却不可以直接对plist文件进行修改。(plist可以变换一种思路进行修改，但是却不建议使用。)</p>
<h4 id="NSUserDefaults存储"><a href="#NSUserDefaults存储" class="headerlink" title="NSUserDefaults存储"></a>NSUserDefaults存储</h4><p><code>NSUserDefaults</code>使用起来简单，如果要存储一些简单的字符串，比如存储字符串，数字等，则<code>NSUSerDefaults</code> 是首选。<br><code>NSUserDefaults</code> 是<code>plist</code>文件的缓存，当用<code>NSUserDefaults</code>写数据的时候，其实是将数据写入到一个专门为<code>NSUserDefaults</code>准备的<code>plist</code>文件中的。 <code>NSUserDefaults</code>可以对这个特殊的<code>plist</code>文件读和写。<br>由于<code>NSUserDefaults</code>会将<code>plist</code>文件的数据读取到缓存中，因此访问速度会很快。</p>
<h4 id="KeyChain"><a href="#KeyChain" class="headerlink" title="KeyChain"></a>KeyChain</h4><p> <code>KeyChain</code>是一个安全的存储容器，所以非常适合保存一些敏感信息到设备中。<code>KeyChain</code>里的数据独立于每个app沙盒之外。即便app被卸载，只要不重新安装系统，存储的信息依然存在，再次安装app，存储的信息依然可以被app使用。通过<code>keychain access groups</code>可以在不同应用之间共享<code>keychain</code>中的数据。要求在保存数据到<code>keychain</code>的时候指定<code>group</code>。<br> 发现百度系的一些app实现的账号互通，应该就是通过<code>keychain access groups</code>来实现的。<br> <code>KeyChain</code>可以存储一些即便app被删除了，下次安装的时候仍然想被用户使用的数据。 </p>
<p> <code>KeyChain</code>数据保存的地方是一个<code>sqlite数据库</code>，位于<code>/private/var/Keychains/keychain-2.db</code>，其保存的所有数据都是加密过的。从这个意义讲，KeyChain的数据是存储在数据库中的，然而由于他只用来存储比较简单的数据，所以就放到了文件分类里。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e621ddc16510e?w=565&amp;h=315&amp;f=jpeg&amp;s=33025" alt=""></p>
<h4 id="NSKeyedArchiver"><a href="#NSKeyedArchiver" class="headerlink" title="NSKeyedArchiver"></a>NSKeyedArchiver</h4><p> 几乎任何类型的对象都能被归档储存。可以使用<code>NSKeyedArchiver</code>进行归档，<code>NSKeyedUnarchiver</code>进行解档。这种方式会在写入、读取数据之前对数据进行序列化、反序列化操作。<br> 对系统自带的简单对象（比如对<code>Foundation</code>框架里的<code>NSString</code>，<code>NSNumber</code>等）可以直接进行归档，而对自定义的对象需要实现NSCoding协议，实现<code>encode</code>和<code>decode</code>方法。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e622225f6850b?w=433&amp;h=203&amp;f=jpeg&amp;s=20884" alt="归档"><br><code>NSKeyedArchiver</code>提供了序列化和反序列化的方法，而真正要存储到文件系统的什么地方是可以自定义的。可以将序列化的数据直接写入到文件系统中。也可以利用<code>NSUSerDefaults</code>写到到<code>plist</code>文件中。<br>所以<code>NSKeyedArchiver</code>非常适合把一个自定义的对象序列化后存储到文件系统中去。 </p>
<h4 id="文件-存储"><a href="#文件-存储" class="headerlink" title="文件 存储"></a>文件 存储</h4><p>将数据转化为<code>NSData</code>对象，然后直接利用系统函数，把数据保存到指定的文件目录下。图片，歌曲，视频一般都是通过这种形式存储的。 </p>
<h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>可以看到，iOS提供一些非常方便的文件存储方式。 如果有些数据结构比较简单，存储的条数不是很多，或者单个的数据量太大（音频文件），一些不用修改的信息，选择iOS系统提供的方法就能完成任务需求。 </p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>当数据信息量比较大，并且结构比较的多的时候，存成文件，每次都要把所有的文件读取完，才能进行文件的统计和相关修改操作。 并且文件系统没法了解文件内部数据之间的关系。因此便有了数据库系统，这个系统专门用维护数据以及数据之间的关系。<br>数据库可以理解为仓库管理系统。 一个家具厂的仓库，要取家具，添加新的家具，把原来的家具改为新的家具样式，都需要通过仓库管理系统来实现。只不过这个数据库管理系统管理的是数据而已。  </p>
<p>iOS也提供了一些操作数据库的实现，包括<code>CoreData</code>和直接操作<code>SQlite数据库</code>。<br>由于CoreData底层的存储方式一般也都是<code>SQLite数据库</code>，因此，本文会详细了解<code>SQLite</code>底层原理及读写锁的控制，并尝试解释<code>CoreData多线程</code>到底做了什么。 </p>
<h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p>了解SQLite数据库之前先了解数据库的基本概念，包括什么是库，什么是表，SQL语句是什么</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>库相当于一个大的仓库。当我们想要使用仓库的时候就需要先建一个仓库。<br>创建<strong>数据库</strong>的语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database xxx;</span><br></pre></td></tr></table></figure>
<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><p>表相当于仓库里具体的一间库房。有的库房专门存放衣服，有的库房专门存放零食。<br>表由字段和记录组成。字段用于组织表结构（即组织库房结构），而记录就是根据字段来存放具体的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `CLOTHES` (</span><br><span class="line">  `key` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `value` char(255) NOT NULL DEFAULT &apos;&apos;,</span><br><span class="line">  PRIMARY KEY (`k`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure>
<p>上面就把表建好了。 key，value就是字段。<br>而真正的存放的每件衣服就是记录。</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p><code>SQL</code> 相当于我们给仓库管理员说的一句话。比如说我们想从1号仓库里的2号房间里拿出来型号为3的衣服。听到这么一句话，仓库管理员就可以行动了。<br><code>SQL</code>是我们同数据库打交道的指令。<br><code>SQL</code> 语句大致可以分为一下几类： </p>
<ul>
<li>数据定义（<code>SQL DDL</code>）用于定义SQL模式、基本表、视图、索引的创建和撤销操作</li>
<li>数据操纵 （<code>SQL DML</code>）数据操纵分成数据查询和数据更新两类。数据更新又分为插入、删除和修改三种操作。也就是我们所说的增删改查操作。</li>
<li>数据控制 （<code>DCL</code>）包括基本表的授权，完整性描述，事务控制等内容。</li>
</ul>
<h3 id="常见的数据库及应用场景"><a href="#常见的数据库及应用场景" class="headerlink" title="常见的数据库及应用场景"></a>常见的数据库及应用场景</h3><p>最常见的数据库模型主要是两种，即关系型数据库和非关系型数据库。</p>
<h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h4><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。<br>在服务端上有<code>Oracle</code>和<code>MySQL</code>。<br>在移动端里最常用的SQlite 就是关系型数据库。本文会对SQLite进行详细的解释。</p>
<h4 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h4><p>非关系型数据库在超大规模和高并发的SNS类型的web2.0纯动态网站中有着非常好的性能。<br><code>NoSQL(NoSQL = Not Only SQL )</code>，意即“不仅仅是SQL”，  泛指非关系型数据库。<br>非关系型数据库 又分为键值存储数据库（key-value）(比如Redis数据库)、列存储（Column-oriented）数据库、面向文档（Document-Oriented）数据库、图形数据库。服务端特别互联网时代，对非关系行数据库有非常广泛的应用。 在移动端有代表性的是Realm。</p>
<h3 id="Sqlite"><a href="#Sqlite" class="headerlink" title="Sqlite"></a>Sqlite</h3><p><code>SQLite</code>，是一款轻型的数据库，是遵守<code>ACID</code>的关系型数据库管理系统。它的设计目标用于嵌入式系统，占用资源少，只需要几百K就够了，并且是跨平台的。目前主流的移动端操作系统Android和iOS的设备内置的都是SQLite数据库。</p>
<blockquote>
<p>ACID，是指数据库管理系统（<code>DBMS</code>）在写入或更新资料的过程中，为保证事务（<code>transaction</code>）是正确可靠的，所必须具备的四个特性：原子性（<code>atomicity</code>，或称不可分割性）、一致性（<code>consistency</code>）、隔离性（<code>isolation</code>，又称独立性）、持久性（<code>durability</code>）。 </p>
</blockquote>
<p>要想优化SQLite运行速度，必须要对SQLite的运行原理有所了解。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6232e5bc8731?w=315&amp;h=383&amp;f=jpeg&amp;s=44910" alt=""><br>它运行共分为4部分。Core层:包括接口层，编译器和虚拟机。 SQL编译层，包括语法分析，词法分析，代码生成。<code>Backend</code>层包括<code>B-Tree</code>、<code>Pager</code>，<code>OS</code>三部分，实现了数据库的主要存储逻辑。 <code>Accessories</code> 是辅助层，包括工具类和测试代码。 </p>
<p>比如一个对<code>Employee</code>表的数据操作流程如下：</p>
<p> 流程大致如下：  1. SQL语句 -&gt; 2.  触发磁盘I/O -&gt;3.磁盘返回一个表对应的<code>Index</code>表的一页Page，包含若干条记录 -&gt; 4. 在上述记录当中找到目标记录，如果没有找到满足条件的记录，则循环第2步骤和第3步骤 直到找到满足条件的记录-&gt; 5.根据<code>Index</code>表的记录里存放的<code>position</code>信息找到原始表记录的位置 -&gt;6.对原始表当中的目标记录进行操作，完成SQL操作。<br> 这里出现了几个名词：<code>Index</code>表和<code>原始表</code>，接下来会进行解释。 </p>
<h4 id="磁盘I-O瓶颈"><a href="#磁盘I-O瓶颈" class="headerlink" title="磁盘I/O瓶颈"></a>磁盘I/O瓶颈</h4><p>我们知道数据库文件其实是放在磁盘上的。而对磁盘的操作要比内存的操作要耗时的多。而一般情况下，一次查询往往无法通过一次I/O 操作完成。所以如何减少磁盘I/O 的次数成为我们优化<code>SQlite</code>性能的关键。 </p>
<h4 id="磁盘读取方式"><a href="#磁盘读取方式" class="headerlink" title="磁盘读取方式"></a>磁盘读取方式</h4><p>磁盘读取方式是以<code>Page</code>为单位。页（<code>page</code>）是计算机存储时，所使用的基础逻辑单位。内存和磁盘中的数据存储和交互都是以页为单位的。即使内存只需要1个字节的数据，从磁盘读取的时候也是拿到一个或多个<code>Page</code>，这是系统级别的一种预先缓存策略。 </p>
<h4 id="Index表"><a href="#Index表" class="headerlink" title="Index表"></a>Index表</h4><p>了解了磁盘I/O非常消耗性能后，我们可以看到如果一个Page里包含的记录比较多，那么SQL每次I/O被命中的概率就更大。 而如果要查询的是一个完整的表，比如一个表里有30个字段，一个字段占用100个字节，那么一个记录占用大概是 30 *100 = 3000 个这字节。假设一页 大小为 4KB，那么一页只存在一个记录。而假设我们使用一个表和原来的表做映射，但是只保留索引字段，比如说只保留key字段，和原始表对应的position字段，那么一页Page就可以装下100多个记录了。 这个和原始表对应的表就叫做<code>索引表</code>。 </p>
<h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>虽然二叉树可以实现log(n)的查找，和插入，但是由于二叉树的每个节点其实对应磁盘的一个<code>Page</code>。所以为了减少磁盘I/O 的次数，需要尽可能减少树的高度。而二叉树类似于一个高瘦的树，我们需要找到一个矮胖的树。 而B树正好符合这个性质。 <code>B树</code>是一个<code>多路查找平衡树</code>，他的每个节点最多包含k个孩子。 k被称为B树的<code>阶</code>。k的大小取决于磁盘页的大小。 </p>
<p><code>SQLite索引表</code>和原始表都是B树形式组织的。<br>也就说如果不建立<code>Index</code>表，原始表的每条记录的大小决定了<code>B树</code>的阶数。 阶数越大，B树越矮胖。<br>也就是要尽量减少原始表和<code>Index</code>表的大小。 尽量少用<code>string</code>类型，而用数值类型的字段。因为数值类型的字段占的字节少。</p>
<h4 id="SQlite-文件"><a href="#SQlite-文件" class="headerlink" title="SQlite 文件"></a>SQlite 文件</h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6240c86a4c4d?w=559&amp;h=366&amp;f=jpeg&amp;s=29584" alt=""><br><code>db</code>文件包括<code>.db</code> 文件,<code>.db_wal</code>文件和<code>.db_shm</code>文件。<br>其中<code>.db</code>文件是各个<code>table</code>存储的位置，原始表和索引表都在这个文件中。<br><code>.db_wal</code>是<code>_journal</code>文件的替代品。所有的事务会先提交到<code>wal</code>文件中，如果事务在写入<code>wal</code>过程中，失败，则把事务丢弃，否则就先存入<code>.db_wal</code>文件中。 然后在某个时机，比如<code>.db_wal</code>的文件达到了设定的阈值，（比如CoreData默认设置大约有4MB左右）会把<code>wal</code>的数据merge到<code>.db</code>文件中。 当然自己也可以手动merge。<br>利用<code>_wal</code>的好处是允许不同的连接，一个读<code>db</code>文件，另个写<code>wal</code>文件。 读和写可以并行。 读和读也可以并发，但是写操作和写操作不能并发。 这个和Sqlite多线程操作原理有关。<br> <code>_shm</code>文件是用来辅助<code>-wal</code>文件的。为了辅助<code>sqlite</code>快速定位<code>wal</code>文件信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e624597c2620e?w=561&amp;h=370&amp;f=jpeg&amp;s=25649" alt=""></p>
<h4 id="SQLite多线程"><a href="#SQLite多线程" class="headerlink" title="SQLite多线程"></a>SQLite多线程</h4><p><code>Sqlite</code>是支持多线程访问的。SQLite支持3种线程模式：</p>
<ol>
<li>单线程： 单线程下会禁用所有的<code>mutex</code>锁，并发使用时会出错。</li>
<li>多线程： 只要一个数据库连接不被多个线程同时使用，就是安全的。底层就是禁用数据库连接和<code>prepared statement</code>上的锁，实现多线程。因此不能在多个线程中并发使用同一个数据库连接和<code>prepared statement</code>。  </li>
<li>串行： 启用所有的锁，包括<code>bCoreMutex</code> 和 <code>bFullMutex</code> 。因为数据库连接和<code>prepared statement</code> 都已加锁，所以多线程使用这些对象时，没法并发，也就变成串行了。</li>
</ol>
<hr>
<blockquote>
<ul>
<li>数据库连接：  每次打开一次数据库，获取到的<code>database</code>就是一个数据库连接 </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static sqlite3 *openDb() &#123;</span><br><span class="line">    if (sqlite3_open(dbPath, &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSLog(@&quot;Failed to open database: %s&quot;, sqlite3_errmsg(database));</span><br><span class="line">    &#125;</span><br><span class="line">    return database;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>Prepared statement</code> ,它是由数据库连接来管理的，使用它也可以看成使用这个数据库连接。 因此在多线程模式下，并发对同一个数据库连接调用<code>sqlite3_prepare_v2()</code>来创建<code>prepared statement</code>，或者对同一个数据库连接的任何<code>prepared statement</code> 并发的调用<code>sqlite3_blind_*()</code>和<code>sqlite3_step()</code>等函数会报错。 </li>
</ul>
</blockquote>
<p>SQLite标准发行版是<code>串行模式</code>，而iOS内置的SQLite库是<code>多线程模式</code>，python的sqlite是用串行模式。 </p>
<p>根据各种模式下线程安全的考虑，可以有四种访问数据库的模式可以选择： </p>
<ol>
<li>SQLite 使用单线程模式，用一个专门的线程访问数据库，需要线程间通讯，实现起来比较麻烦。</li>
<li>SQlite 使用单线程模式，用一个线程队列来访问数据库， 队列一次只允许一个线程执行，队列里的线程公用一个数据库连接。 可以使用<code>dispatch_queue_create()</code>来创建一个<code>serial queue</code>,来作为队列。</li>
<li>SQLite使用多线程模式，每个线程创建自己的数据库连接。<br>这种情况需要每次都要打开和关闭数据库连接，所以会额外消耗一些时间。这种情况可以选用一个<code>并发队列</code>。每次读写的时候都要开启和关闭数据库连接 。</li>
<li>SQLite使用串行模式，所有的线程公用全局的数据库连接<br><code>SQLite</code>的串行模式相当于让<code>SQlite</code>自己来维护队列，只不过SQL的执行是乱序的，因此无法保证事务性。 </li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e624d3b5f2601?w=363&amp;h=350&amp;f=jpeg&amp;s=46302" alt=""></p>
<h4 id="FMDB多线程"><a href="#FMDB多线程" class="headerlink" title="FMDB多线程"></a>FMDB多线程</h4><p><code>FMDB</code>是用于数据存储的框架。它是iOS平台下对<code>SQLite</code>数据的封装，<code>FMDB</code>是面向对象的，它以OC语言封装了<code>SQLite</code>的C语言的API，使用起来非常方便。是iOS平台上使用最多的第三方数据存储框架。 </p>
<p>FMDB使用iOS官方的SQLite库，也就是默认模式是多线程模式。</p>
<p>FMDB中对多线程的管理是用串行队列来完成的。用 <code>FMDatabaseQueue</code>来管理这个队列。<br><code>FMDatabaseQueue</code>初始化的时候，初始化了一个串行队列，并给其添加唯一标识： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_queue = dispatch_queue_create([[NSString stringWithFormat:@&quot;fmdb.%@&quot;, self] UTF8String], NULL);</span><br><span class="line">        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL);</span><br></pre></td></tr></table></figure>
<p>而当操作数据库的时候，使用了这个串行队列并且同步执行。这样能够保证一个数据库连接在同一时刻只有一个事务在操作数据库。就满足了SQLite数据库同一时刻不能有多个操作的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_sync(_queue, ^() &#123;</span><br><span class="line">     ///数据库操作</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>一个FMDatabaseQueue就是一个串行队列。就算你开启多线程执行，它依然还是串行执行的。保证了线程的安全性。</p>
<p>如果想实现多个线程操作数据库，可以创建多个<code>FMDatabaseQueue</code> ，虽然每个<code>queue</code>内部是串行运行的，但是<code>queue</code>与<code>queue</code>可以并发执行。 </p>
<p><code>FMDB</code>使用了一个串行队列，并且同步执行，假如这个串行队列中有两个任务，任务1先开始，任务1依赖于任务2的执行结果，任务2需要等待任务1执行完，才开始执行，那么就会出现死锁。所以在使用FMDB的时候一定要注意，尽量不要在任务中嵌套使用 。<br><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e6270e081c964?w=800&amp;h=514&amp;f=jpeg&amp;s=107050" alt=""></p>
<h4 id="Core-Data多线程"><a href="#Core-Data多线程" class="headerlink" title="Core Data多线程"></a>Core Data多线程</h4><p><code>Core Data</code> 是苹果官方推出的数据持久化框架。它类似与<code>ORM</code>（对象关系映射），但是要比ORM做的更多。<code>Core Data</code>存储一般选用<code>SQLite</code>数据库作为持久化存储区，但是也可以选用二进制，XML等形式的持久化存储。<br>在使用SQLite的时候，<code>CoreData</code> 默认是开启多线程模式的。<br>从<code>NSManagedObjectContext</code>不能跨线程使用来看，<code>Core Data</code>在实现上可能是一个<code>MOC</code>对象对应着一个数据库连接。 所以建立连接的时候有如下规定：</p>
<ul>
<li>不同的线程要建立自己的<code>NSManagedObjectContext</code>，维护自己的对象。 </li>
<li><p><code>NSManagedObject</code> 对象不能跨线程使用。 </p>
<p>由于数据库操作的时候，不能跨线程，并且需要同步，为了防止死锁等问题，现有比较好的解决方案是利用三层<code>NSManagedObjectContext</code> 来操作数据库。 </p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/21/162e628810d2ab34?w=856&amp;h=735&amp;f=jpeg&amp;s=128002" alt=""></p>
<p>MOC 可以设置<code>parentContext</code> ,一个<code>parentContext</code>可以拥有多个<code>childContext</code>，在<code>childContext</code>执行的<code>Save</code>操作，会将操作<code>push</code>到<code>parentContext</code>中，由<code>parentContext</code>来执行真正的<code>save</code>操作。而<code>childContext</code>的所有改变会被<code>parentContontext</code>知晓。 这样解决了手动同步的问题。 </p>
<p>三层模型可以让我们在<code>MainContext</code>里执行UI相关的操作，而保存操作会在子线程 <code>Context</code>中，子线程是后台线程，当执行save的时候，会把状态保存到<code>MainContext</code> 中，<code>MainContext</code> 再次<code>save</code> 的时候，会把状态保存到最上层的唯一的私有<code>context</code>中。当<code>最上层的context</code>执行了save，才会真正触发执行把数据保存到数据库中的操作。 由于最上层的操作，是在子线程进行的，所以不会影响UI。<br>这里需要注意的是最下面的子线程 <code>Context</code>可以有多个。并且应用原则应该是用完即扔，不用保存这个<code>Context</code>。这样不会导致<code>Context</code>混乱的问题。 子Context之间不用进行通讯，意义不大，还会惹出一堆问题。我们的<code>MainContext</code>全程只有一个，用来进行UI相关的操作。并且最上层的私有context也是唯一一个。这就保证了我们只有一个数据库连接。<br>这样以后，其实是人为的保证了最上层只有一个<code>Context</code> 在和数据库打交到。 而这个<code>Context</code>又是在单个线程下的。所以能够保证对SQLite的操作是能满足多线程模式的要求的。<br>然而也可以看出，这样的操作，并没有发挥出多线程模式的优势来。有点类似于串行模式。<br>但是这样能够保证线程安全，并且不会阻塞主线程。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>iOS端的存储方案有很多。到底选择哪种存储方案，还是要依赖于当时的业务场景出发。本文大体介绍了各种存储方式的原理，进而来探讨各个方案优劣点，及使用场景。 并没有对各个方案的实现细节有太多的描述。文件存储方案实现简单，在较简单的场景下非常有用。 数据库存储适合比较复杂的业务场景。当然坑也非常多，也有很多技术难点，在接下的文章中我们会对<code>FMDB</code>，<code>CoreData</code>进行详细的探讨。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><p><a href="http://www.jianshu.com/p/cf76e2e81230" target="_blank" rel="noopener">iOS进阶——SQLite数据库</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/stephen-liu74/archive/2012/03/02/2328753.html" target="_blank" rel="noopener">SQLite学习手册(锁和并发控制)</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/107c6b045245" target="_blank" rel="noopener">超全的数据库分类介绍</a></p>
</li>
<li><p><a href="http://blog.csdn.net/zhoudaxia/article/details/8196838" target="_blank" rel="noopener">SQLite剖析(5)：体系结构</a></p>
</li>
<li><p><a href="https://www.keakon.net/2011/10/25/SQLite%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">SQLite在多线程环境下的应用</a></p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286361&amp;idx=1&amp;sn=78bbcda7f41a14291ad71289e4821f71&amp;scene=21" target="_blank" rel="noopener">微信iOS SQLite源码优化实践</a></p>
<ul>
<li><a href="http://blog.csdn.net/yixiangboy/article/details/51274189" target="_blank" rel="noopener">IOS开发源码阅读篇–FMDB源码分析3</a></li>
</ul>
</li>
<li><p><a href="http://blog.flight.dev.qunar.com/2016/11/10/ios-data-persistence-learn/" target="_blank" rel="noopener">iOS 中数据持久化的几种方式</a></p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/25/如何更改-Mac-文件的默认打开方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujunlong">
      <meta itemprop="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junlong的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/如何更改-Mac-文件的默认打开方式/" itemprop="url">
                  如何更改 Mac 文件的默认打开方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-25 10:30:49 / Modified: 10:32:08" itemprop="dateCreated datePublished" datetime="2018-06-25T10:30:49+08:00">2018-06-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何更改-Mac-文件的默认打开方式"><a href="#如何更改-Mac-文件的默认打开方式" class="headerlink" title="如何更改 Mac 文件的默认打开方式"></a>如何更改 Mac 文件的默认打开方式</h1><p>更改同类型文件的默认打开方式<br>第一步：右键单击该文件，然后选择「显示简介」选项。</p>
<p><img src="http://imageliujunlong.test.upcdn.net/2018/06/25/15298937236746.jpg" alt=""></p>
<p>第二步：找到「打开方式」项目，点击倒三角选择你想指定的默认应用程序。<br><img src="http://imageliujunlong.test.upcdn.net/2018/06/25/15298937577070.jpg" alt=""></p>
<p>第三步：单击「全部更改」按钮即可生效。</p>
<p><img src="http://imageliujunlong.test.upcdn.net/2018/06/25/15298937810043.jpg" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/24/高效能人士的七个习惯-读书笔记1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujunlong">
      <meta itemprop="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junlong的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/24/高效能人士的七个习惯-读书笔记1/" itemprop="url">
                  高效能人士的七个习惯 -- 读书笔记1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-24 17:28:46 / Modified: 23:51:19" itemprop="dateCreated datePublished" datetime="2018-06-24T17:28:46+08:00">2018-06-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://imageliujunlong.test.upcdn.net/2018/06/24/15298324400769.jpg" alt=""></p>
<h1 id="高效能人士的七个习惯-–-读书笔记1"><a href="#高效能人士的七个习惯-–-读书笔记1" class="headerlink" title="高效能人士的七个习惯 – 读书笔记1"></a>高效能人士的七个习惯 – 读书笔记1</h1><h2 id="第一部分为重新探索自我，由内而外的全面造就自己。"><a href="#第一部分为重新探索自我，由内而外的全面造就自己。" class="headerlink" title="第一部分为重新探索自我，由内而外的全面造就自己。"></a>第一部分为重新探索自我，由内而外的全面造就自己。</h2><h3 id="探索自我的原因"><a href="#探索自我的原因" class="headerlink" title="探索自我的原因"></a>探索自我的原因</h3><p>现在很多人面临的问题是表面上事业有成，内心却感到匮乏，他们都极度渴望过上和谐，圆满的生活，并享有不断展开的良好的人际关系，但是他们面临的根本问题是：<br>   每个人的思维是多么的根深蒂固，并且了解到，认识不仅是认识外在的世界，更与我们向外看时，所透过的镜片有关，因为这些镜片（即思维）往往左右着我们对外界的诠释。<br>   要改变现状，就得改变自己，要改变自己，先得改变我们看待外界的观点。<br>   很多书籍或讲座都在讲如何运用社会形象的技巧与如何成功的捷径，但是往往是头痛医头脚痛医脚的特效治疗，治标不治本。</p>
<h3 id="品德的意义"><a href="#品德的意义" class="headerlink" title="品德的意义"></a>品德的意义</h3><p>而品德成功论强调圆满的生活与基本品德是区分不开的。唯有修养自己具备品德，才能享受真正的成功与恒久的快乐从容。这些品德包括正直，谦虚，诚信，勤勉，朴实，耐心，勇气等。<br>不要讲究技巧，而着重调整内心真正的动机。<br>个人魅力论所强调的重点，如追求个人成长，训练沟通技巧，培养积极思考和发挥影响力，它们有时确实是成功的要素，但是这些只是次要的，不是最根本的优点。<br>唯有基本的品德能够为人际关系技巧赋予生命。品德才是沟通的利器，大声喧哗反而难以入耳。</p>
<h3 id="思维的意义"><a href="#思维的意义" class="headerlink" title="思维的意义"></a>思维的意义</h3><p>思维是我们看待外面世界的观点。<br>我们的所见所闻并非来自感官，而是透过主管的了解与诠释。<br>思维不是实际的实物，而是对事物的诠释和理解。<br>唯有方向（思维）正确，努力才有意思。<br>每个人脑海中有许多区域，大致可以分为两大类：一类关于现实世界的，一类是有关个人价值判断的。思维决定着一个人的思想与行为。<br>不同的人对同样一件事会有不同的看法。<br>人的一生中来自家庭、学校、工作环境、新友同事，宗教以及流行思潮的影响力均在不知不觉中制约着我们，左右着我们的思维 –思维地图<br>一般人总认为自己的观点正确且立场客观，但实验却证明，虽然别人的结论不同，不代表他们是主管的，错误的。<br>其实观点不同，以致看法不同是完全正确的现象。</p>
<h3 id="思维转换，建立全新的观点"><a href="#思维转换，建立全新的观点" class="headerlink" title="思维转换，建立全新的观点"></a>思维转换，建立全新的观点</h3><p>第一印象对你的影响愈大，顿悟时的刺激也就愈大。<br>每一项科学研究的重大突破，几乎都是先打破传统，打破旧思维，而后才成功的。 </p>
<h3 id="反求诸己，由内而外"><a href="#反求诸己，由内而外" class="headerlink" title="反求诸己，由内而外"></a>反求诸己，由内而外</h3><p>一般重大问题发生时，依我们当时的思想水平往往无法解决。<br>而解决这些问题比较好的方式是可以以原则为中心，以品德为基础，以及能达到个人效能和人际关系效能的由内而外的修炼。<br>由内而外，即反求诸己，由个人最基本的部分，思维、品德与动机一一做起。<br>比如如果你们希望才华不被埋没，那么先修养自己的基本品德。<br>如果你希望在工作上享有更多自由与自主，那么先做个更负责尽职的员工。</p>
<p>由内而外修炼强调，先追求个人的成功才能有人际关系的成就，先信守对自己的承诺，才能信守对他人的承诺。<br>我们所提供的反求诸己，由内而外的思维，因为个人魅力论的流风所及，再加上传统观念的影响，因此当事人往往需要大幅度的自我调整才能转换思维。</p>
<h1 id="第二章-七个习惯-–-概论"><a href="#第二章-七个习惯-–-概论" class="headerlink" title="第二章 七个习惯 – 概论"></a>第二章 七个习惯 – 概论</h1><p>习惯，对于我们的生活有绝大的影响，因为它是一贯的，在不知不觉中，经年累月影响着我们的品德，暴露出我们的本性，左右着我们的习惯。</p>
<h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>人们的行为总是一再重复的，因此卓越不是单一的举动，而是习惯。<br>习惯可以养成，也可以打破，但绝不是一蹴而就的。而是需要长期的努力与无与伦比的毅力。<br>习惯就如人前往太空一样，具有极大的引力。想要革除因循苟且，缺乏耐心，吹毛求疵或者自私自利等不良习惯，若是缺乏意志力，不能大刀阔斧的改革，难以实现目标。“起飞”需要极大的努力，然而一旦脱离重力的牵绊我们便可享受前所未有的自由。<br>习惯的引力如同自然界的所有力量一样，可以为我们所用，也可能危害我们，关键看我们如何运用。 </p>
<h2 id="习惯的定义"><a href="#习惯的定义" class="headerlink" title="习惯的定义"></a>习惯的定义</h2><p>   习惯定义为知识、技巧与意愿三者的混合体。知识是理论性的观念，指点我们做什么以及为什么做。技巧指示我们如何做。意愿是想做，表示我们有什么行动的愿望。 培养一种习惯，这三项要素缺一不可。<br>   改变习惯的过程，很不好受。毕竟习以为常的事物比较给人安全感。但为追求一生的幸福与成功，暂时牺牲眼前的安适与近期的利益，也是值得的。 经过一番努力与牺牲所换来的果实，将更为甜美。<br>   在不断提升自我的同时，我们可体会宇宙万物唇齿相依的关系，包括人类社会在内，整个大自然共享一个生态，个人无法离群索居。</p>
<h2 id="成熟模式图"><a href="#成熟模式图" class="headerlink" title="成熟模式图"></a>成熟模式图</h2><p>成熟模式图即人类成长的三个阶段，分别为依赖期、独立期、互赖期。<br>依赖期：围绕着你这个观念 – 你依赖我。<br>独立期：着眼于我的观念– 我可以自立，我为自己负责。<br>互赖期：从我们的观念出发 – 我们可以互相合作，共创伟大前程。<br>依赖心重的人，靠别人来完成愿望；独立自主的人，自己打天下；互赖的人，群策群力以达成功。<br>独立比依赖成熟的多，不过独立并非个人成长的极致；只可惜当前的社会价值观将独立奉为圭臬，大多励志书籍也强调独立，仿佛沟通、团队精神病不重要。</p>
<h2 id="互赖的观念"><a href="#互赖的观念" class="headerlink" title="互赖的观念"></a>互赖的观念</h2><p>只有独立的人才能达到互赖的境界。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/23/Xcode9适配问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="liujunlong">
      <meta itemprop="description" content="记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu">
      <meta itemprop="image" content="/images/avatar1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="junlong的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/23/Xcode9适配问题/" itemprop="url">
                  Xcode9适配问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-23 23:27:20" itemprop="dateCreated datePublished" datetime="2018-06-23T23:27:20+08:00">2018-06-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-06-24 10:35:56" itemprop="dateModified" datetime="2018-06-24T10:35:56+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Xcode9-遇到的坑"><a href="#Xcode9-遇到的坑" class="headerlink" title="Xcode9 遇到的坑"></a>Xcode9 遇到的坑</h1><p>更新iOS11以及Xcode9beta项目遇到的坑</p>
<p>由于更新手机系统iOS11以及xcode9 beta，然后项目在xcode9运行出现一些错误：Compiling IB documents for earlier than iOS 7 is no longer supported.如截图<img src="http://imageliujunlong.test.upcdn.net/2018/06/23/15041723996257.png" alt=""></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法是：Builds for更改版本7之后，我更改成7<img src="http://imageliujunlong.test.upcdn.net/2018/06/23/15041724330006.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar1.jpg"
                alt="liujunlong" />
            
              <p class="site-author-name" itemprop="name">liujunlong</p>
              <p class="site-description motion-element" itemprop="description">记录点点滴滴的感悟, iOS ,技术 刘俊龙， liujunlong ,龙猫，longmao, baidu</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liujunlong</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
